/****************************************************错误总结&修改说明*************************************************/

/**20210317-改变吸附材料**/
/**20210317-校核制冷剂压降+切换过程空气侧热容质容影响**/
/**20210317-添加输出文件**/
/**20210716-添加注释；整理输出文件**/

/********************************************************预编译********************************************************/

/**调用库**/
#include <iostream>
#include <cmath>
#include <fstream>

/**宏定义**/
#define pi 3.14159265

using namespace std;
/*******************************************************函数声明********************************************************/

double SaturatedLPT(double Tsat);
double SaturatedGPT(double Tsat);
double SaturatedLHT(double Tsat);
double SaturatedGHT(double Tsat);

double SaturatedLTP(double Psat);
double SaturatedGTP(double Psat);
double SaturatedLTH(double hL);
double SaturatedLST(double T);

double SaturatedGRouT(double Tsat);
double SaturatedLRouT(double Tsat);

double TwoPhaseHX(double x, double Psat);
double TwoPhaseXH(double h, double Psat);
double TwoPhaseTH(double h, double Psat);
double TwoPhaseSH(double h, double Psat);

double SuperHeatedHT(double P, double T);
double SuperHeatedTH(double P, double h);
double SuperHeatedST(double P, double T);
double SuperHeatedTS(double P, double s);
double SuperHeatedCpT(double P, double T);
double SuperHeatedRouT(double P, double T);

double SubCooledHT(double P, double T);
double SubCooledTH(double P, double h);
double SubCooledCpT(double P, double T);
double SubCooledRouT(double P, double T);

inline double SaturatedLUT(double Tr);
inline double SaturatedGUT(double Tr);

double first_modified_Bessel(int n,double x);
double second_modified_Bessel(int n,double x);

/**通过送风需求计算运行时间**/
inline double YSA2top(bool flag_print, double Gr, double Tr_CD,
                        double Tr_EV, double Wd_EV_start,
                        double hs_EV, double cp_eq_EV, double Ky_EV, double hr_EV,
                        double Ta_EVin, double Ya_EVin, double &Ta_EVout_targ, double &Y_SA_temp, double &Wd_EV,
                        double EXa_EVin, double &EXr_EVin_targ, double &EXd_EVstart, double &EXa_EVout_targ, double &EXr_EVout_targ, double &EXd_EVend, double &dltEX_EV_targ,
                        double Wda[], double RHa[], double Wdd[], double RHd[]);
/**通过能量校核计算冷凝温度**/
inline double TrCD2dltQ(bool flag_print, double Tr_CD,
                         double Tr_EV, double dltIEV_qst, double Wd_CD_start, double t_OP, double &Gr,
                         double Ya_CDin, double Ta_CDin, double hs_CD, double cp_eq_CD, double Ky_CD, double hr_CD, double &Wd_CD,
                         double EXa_CDin, double &EXr_CDin, double &EXd_CDstart, double &EXr_CDout, double &EXa_CDout_targ, double &EXd_CDend, double &dltEX_CD_targ,
                         double &P_CM, double &dltEX_CM, double &dltEX_TV,
                         double Wda[], double RHa[], double Wdd[], double RHd[]);

inline double Tr2Uo(double Tr, double Wd, double Yain, double Tain, double ua, double hs, double cp_eq, double Ky, double hr, double &Td, double &Yd,
                    double Wda[], double RHa[], double Wdd[], double RHd[]);

inline double Ir2Sr(double ir, double pr, double &sr, double &rour);
inline double Update_Hs(double ua);
inline double Update_Ky(double ha, double Ta);
inline double Update_dltP(double ua);
inline double Update_dltPr(double Tr, double Gr, double xr_start);
inline double Update_Frict_TwoPhase(double Tr, double Gr, double xr);

inline double T2Psat(double T);
inline double Wd2Yd (bool flag_ch, double Td, double Wd, double Wda[], double RHa[], double Wdd[], double RHd[]);
inline double Wd2EXd (double Td, double Wd, double Wda[], double RHa[], double Wdd[], double RHd[]);

/*****************************************************全局变量定义****************************************************/

/**计算常量，未赋值的全局变量 Global Variables**/
double Patm = 1.01325e5, g = 9.8;
double dlt = 1, dltT0 = 1, dltT1 = 0.1, dltT2 = 0.005;
int N_Wda, N_Wdd;

/**物性常数 Material Properties**/
double roua = 1.2, cpa = 1035.0, ka = 0.0321, mua = 1.845e-5;
double cpv = 1864.0, cpw = 4200.0;
double hfg = 2501000;
double qst = 2700000;
double roual = 2700.0, roucu = 8900.0;                                         /**翅片密度，铜管密度**/
double cal = 880.0, ccu = 390.0;                                               /**翅片比热容，铜管比热容**/
double kf = 203.0, kt = 407.0;
double roud = 1000, kd = 0.35, cd = 1000;

/**几何常数 Geometric Parameters**/
double dlx = 22.5e-3, dlz = 24e-3;                                             /**微元横截面长、宽**/
double ro = 4.76e-3, ri = 3.925e-3;                                            /**管外径，管内径**/
double r1 = ro, r2 = sqrt(dlx * dlz / pi);                                     /**微元截面等效半径**/
double tf = 1.5e-4, Pf = 2.5e-3;
double td = 1.5e-4;
int ntz = 12, ntx = 4, nf = 128;                                               /**换热器管排数12（列数为4），翅片数128**/
double Lx = dlx * ntx;
double Af = Pf * nf * dlz * ntz;                                               /**迎风面积**/
double Ato = 2 * pi * ro * (Pf - tf) * nf * ntx * ntz, Afo = 2 * (dlx * dlz - pi * pow (ro,2)) * nf * ntx * ntz, Ao = Ato + Afo;                             /**空气测换热面积**/
double lt = Pf * nf * ntx * ntz, Ati = 2 * pi * ri * lt;                                                                                                                       /**制冷剂侧换热面积**/
double Va = dlx * dlz * lt, la = Va / Ao;                                                                                                                          /**微元体积**/
double Val = (dlx * dlz - pi * pow (ro,2)) * tf * nf * ntx * ntz;                      /**微元铝体积**/
double Vcu = lt * pi * (pow (ro,2) - pow (ri,2));                                                                                                    /**微元铜体积**/
double Vd = Ao * td;

/**系统输入量&可能要变化的量 Operational Parameters**/
double T_OA = 35, Y_OA = 14;
double T_RA = 27, Y_RA = 10;
double Psat_OA = T2Psat(T_OA);
double Y_OA_sat = 622 / (Patm / Psat_OA - 1);

double Q_total = 2e3;
double QL_ratio = 0.3;
double ua_EV, ua_CD;
double GOA_EV, GOA_EV0 = 0.03;

double yt_CM = 0.85;
double ytele_CM = 0.9;
double yt_DF = 0.35;
double t_SW = 20;

 ofstream outfile_EV;
 ofstream outfile_CD;
 ofstream outfile_EX;

/********************************************************主函数********************************************************/

int main(){

    /**定义输入输出文件 Define input and output file**/
    ifstream infile1("0-1-Isotherm-S2-35-45.txt");
    outfile_EV.open("EV Outlet Air.txt");
    outfile_CD.open("CD Outlet Air.txt");
    outfile_EX.open("Exergy Consumption.txt");

    double U_ratio;

    double i_OA, i_RA;
    double Ga_EV, OA_ratio_EV;
    double ia_EVin, Ya_EVin, Ta_EVin;
    double EXa_RA_EV, EXa_OA_EV, EXa_EVin, dltEX_mix1;

    double Ga_CD, RA_ratio_CD;
    double ia_CDin, Ya_CDin, Ta_CDin;
    double EXa_RA_CD, EXa_OA_CD, EXa_CDin, dltEX_mix2;

    double hs_EV, Ky_EV, cp_eq_EV, hr_EV;
    double hs_CD, Ky_CD, cp_eq_CD, hr_CD;

    bool flag_Wd, flag_Wd_print;
    int times_Wd;
    double Wd_CD_end, Wd_CD_BFR;

    bool flag_t_OP, flag_t_OP_print;
    int times_t_OP;
    double t_OP_try;

    bool flag_Tr_EV, flag_Tr_EV_print;
    int times_Tr_EV;
    double Tr_EV, Tr_EV_Rtry0, Tr_EV_Rtry1, Tr_EV_Rtry2;
    double Tr_EV_try1, Tr_EV_try2, Tr_EV_temp;
    double dltTSA_try1, dltTSA_try2;
    double i_SA, Y_SA, T_SA, Ta_EVout_arg, ia_EVout_arg, dltIEV_qst_arg;
    double EXd_EV_start, EXr_EVin_arg, EXa_EVout_arg, EXr_EVout_arg, EXd_EV_end, dltEX_EV_arg;
    double t_OP, Wd_EV_end;

    bool flag_Tr_CD, flag_Tr_CD_print;
    int times_Tr_CD;
    double Tr_CD, Tr_CD_temp;
    double Tr_CD_try1, dltQ_CD_try1;
    double Tr_CD_try2, dltQ_CD_try2;
    double EXd_CD_start, EXr_CDin_arg, EXr_CDout_arg, EXa_CDout_arg, EXd_CD_end, dltEX_CD_arg;
    double P_CM_arg, dltEX_CM_arg, dltEX_TV_arg;

    double Gr_CM;


    /**0. 准备工作：输入等温吸附曲线 Preliminary Work**/
    //;
    infile1>>N_Wda>>N_Wdd;
    cout<<N_Wda<<'\t'<<N_Wdd<<endl;
    double *MWda, *MRHa;
    double *MWdd, *MRHd;

    MWda = new double[N_Wda];
    MRHa = new double[N_Wda];
    MWdd = new double[N_Wdd];
    MRHd = new double[N_Wdd];
    int i;
    for(i = 0; i < N_Wda; i++){
        infile1>>MRHa[i]>>MWda[i];
        MRHa[i] = MRHa[i] / 100, MWda[i] = MWda[i] * 0.64;
        if(i < N_Wdd){
            infile1>>MRHd[i]>>MWdd[i];
            MRHd[i] = MRHd[i] / 100, MWdd[i] = MWdd[i] * 0.64;
        }
    }

  for (ua_EV = 1.0; ua_EV <= 2.05; ua_EV = ua_EV + 0.2){
        for (U_ratio = 0.7, ua_CD = U_ratio * ua_EV; ua_CD < min(2.05 * ua_EV, 3.0); U_ratio = U_ratio + 0.1, ua_CD = U_ratio * ua_EV){

            if(ua_CD < 0.850)continue;

            /**1.1. 计算新风回风焓&送风量 OA Enthalpy and Flow Rate**/
            i_OA = cpa * T_OA + Y_OA / 1000 * (hfg + cpv * T_OA);
            i_RA = cpa * T_RA + Y_RA / 1000 * (hfg + cpv * T_RA);
            Ga_EV = ua_EV * Af * roua;

            /**一层迭代 First-layer Iteration**/
            Wd_CD_end = 0.1;
            flag_Wd_print = 1, flag_Wd = 1;
            times_Wd = 0;
            while (flag_Wd_print || flag_Wd){

                /**二层迭代 Second-layer Iteration**/
                t_OP_try = 180;
                flag_t_OP = 1, flag_t_OP_print = 1;
                times_t_OP = 0;
                while (flag_t_OP_print || (flag_t_OP && !flag_Wd_print)){

                    /**1.1.蒸发侧新风量&&新风与回风混合得到的混风状态**/
                    GOA_EV = GOA_EV0 * (t_SW + t_OP_try) / t_OP_try;
                    OA_ratio_EV = GOA_EV / Ga_EV;
                    ia_EVin = OA_ratio_EV * i_OA + (1 - OA_ratio_EV) * i_RA;
                    Ya_EVin = OA_ratio_EV * Y_OA + (1 - OA_ratio_EV) * Y_RA;
                    Ta_EVin = (ia_EVin - Ya_EVin / 1000 * hfg) / (cpa + cpv * Ya_EVin / 1000);

                    /**1.2. 蒸发侧传递系数**/
                    hs_EV = Update_Hs(ua_EV);
                    Ky_EV = Update_Ky(hs_EV,Ta_EVin);
                    cp_eq_EV = cpa + Ya_EVin / 1000 * cpv;
                    hr_EV = 100 * hs_EV;

                    /**1.3. 蒸发侧新风回风火用&蒸发侧入口混风火用**/
                    EXa_RA_EV = (1 - OA_ratio_EV) * Ga_EV * ((cpa + Y_RA / 1000 * cpv) * (T_OA + 273.15) * ((T_RA + 273.15) / (T_OA + 273.15) - 1 - log((T_RA + 273.15) / (T_OA + 273.15))) + 8.314e3 / 29 * (T_OA + 273.15) * ((1 + 1.608 * Y_RA / 1000) * log((1 + 1.608 * Y_OA_sat / 1000)/(1 + 1.608 * Y_RA / 1000)) + 1.608 * Y_RA / 1000 * log(Y_RA / Y_OA_sat)));
                    EXa_OA_EV = OA_ratio_EV * Ga_EV * 8.314e3 / 29 * (T_OA + 273.15) * ((1 + 1.608 * Y_OA / 1000) * log((1 + 1.608 * Y_OA_sat / 1000)/(1 + 1.608 * Y_OA / 1000)) + 1.608 * Y_OA / 1000 * log(Y_OA / Y_OA_sat));
                    EXa_EVin = Ga_EV * (cpa + Ya_EVin / 1000 * cpv) * (T_OA + 273.15) * ((Ta_EVin + 273.15) / (T_OA + 273.15) - 1 - log((Ta_EVin + 273.15) / (T_OA + 273.15))) + Ga_EV * 8.314e3 / 29 * (T_OA + 273.15) * ((1 + 1.608 * Ya_EVin / 1000) * log((1 + 1.608 * Y_OA_sat / 1000)/(1 + 1.608 * Ya_EVin / 1000)) + 1.608 * Ya_EVin / 1000 * log(Ya_EVin / Y_OA_sat));
                    dltEX_mix1 = EXa_RA_EV + EXa_OA_EV - EXa_EVin;

                    /**2.1. 初步估计合适的蒸发温度（以在合适切换时间内得到预定送风湿度）**/
                    flag_Tr_EV_print = 1;
                    for (Tr_EV_Rtry0 = 20; Tr_EV_Rtry0 > 0; Tr_EV_Rtry0 = Tr_EV_Rtry0 - dltT0){
                        t_OP = YSA2top(flag_Tr_EV_print,Gr_CM,Tr_CD,                         /**计算结束指标**/
                                       Tr_EV_Rtry0,Wd_CD_end,
                                       hs_EV,cp_eq_EV,Ky_EV,hr_EV,Ta_EVin,Ya_EVin,
                                       Ta_EVout_arg,Y_SA,Wd_EV_end,
                                       EXa_EVin,EXr_EVin_arg,EXa_EVout_arg,EXd_EV_start,EXr_EVout_arg,EXd_EV_end,dltEX_EV_arg,
                                       MWda,MRHa,MWdd,MRHd);

                        if (t_OP >= 180 && t_OP <= 2000) break;
                    }
                    i_SA = - Q_total * (t_SW + t_OP) / t_OP / ua_EV / Af / roua + i_RA;
                    T_SA = (i_SA - Y_SA / 1000 * hfg) / (cpa + cpv * Y_SA / 1000);


                    for (Tr_EV_Rtry1 = Tr_EV_Rtry0 + dltT0; Tr_EV_Rtry1 > Tr_EV_Rtry0; Tr_EV_Rtry1 = Tr_EV_Rtry1 - dltT1){
                        t_OP = YSA2top(flag_Tr_EV_print,Gr_CM,Tr_CD,
                                       Tr_EV_Rtry1,Wd_CD_end,
                                       hs_EV,cp_eq_EV,Ky_EV,hr_EV,Ta_EVin,Ya_EVin,
                                       Ta_EVout_arg,Y_SA,Wd_EV_end,
                                       EXa_EVin,EXr_EVin_arg,EXd_EV_start,EXa_EVout_arg,EXr_EVout_arg,EXd_EV_end,dltEX_EV_arg,
                                       MWda,MRHa,MWdd,MRHd);
                        if (t_OP >= 180 && t_OP <= 2000) break;
                    }
                    for (Tr_EV_Rtry2 = Tr_EV_Rtry1 + dltT1; Tr_EV_Rtry2 > Tr_EV_Rtry1; Tr_EV_Rtry2 = Tr_EV_Rtry2 - dltT2){

                        t_OP = YSA2top(flag_Tr_EV_print,Gr_CM,Tr_CD,
                                       Tr_EV_Rtry2,Wd_CD_end,
                                       hs_EV,cp_eq_EV,Ky_EV,hr_EV,Ta_EVin,Ya_EVin,
                                       Ta_EVout_arg,Y_SA,Wd_EV_end,
                                       EXa_EVin,EXr_EVin_arg,EXd_EV_start,EXa_EVout_arg,EXr_EVout_arg,EXd_EV_end,dltEX_EV_arg,
                                       MWda,MRHa,MWdd,MRHd);

                        i_SA = - Q_total * (t_SW + t_OP) / t_OP / ua_EV / Af / roua + i_RA;
                        T_SA = (i_SA - Y_SA / 1000 * hfg) / (cpa + cpv * Y_SA / 1000);
                        //cout<<"ERROR!!!"<<t_OP<<'\t'<<i_SA<<'\t'<<Y_SA<<'\t'<<T_SA<<endl;

                        if (!flag_Tr_EV_print) break;
                        if (t_OP >= 180 && t_OP <= 2000) {
                            if (flag_t_OP_print || Ta_EVout_arg >= T_SA) break;
                            else {flag_Tr_EV_print = 0; Tr_EV_Rtry2 = Tr_EV_Rtry2 + dltT2;}
                        }
                    }

                    cout<<"Rough EV temperature!!!"<<'\t'<<t_OP<<'\t'<<Tr_EV_Rtry2<<'\t'<<Ta_EVout_arg<<'\t'<<T_SA<<endl;

                    /**2.2. 在预估出风温度高于设定值的条件下，重新迭代合适的蒸发温度以得到合适的送风温度**/
                    /**三层迭代**/
                    if (Ta_EVout_arg < T_SA) flag_Tr_EV_print = 0;
                    else {flag_Tr_EV = 1, flag_Tr_EV_print = 1;}
                    times_Tr_EV = 0;
                    Tr_EV_try1 = Tr_EV_Rtry2 - 1, Tr_EV_try2 = Tr_EV_Rtry2;
                    while (flag_Tr_EV_print || (flag_Tr_EV && !flag_t_OP_print)){
                        t_OP = YSA2top(1,Gr_CM,Tr_CD,
                                       Tr_EV_try1,Wd_CD_end,
                                       hs_EV,cp_eq_EV,Ky_EV,hr_EV,Ta_EVin,Ya_EVin,
                                       Ta_EVout_arg,Y_SA,Wd_EV_end,
                                       EXa_EVin,EXr_EVin_arg,EXd_EV_start, EXa_EVout_arg,EXr_EVout_arg,EXd_EV_end,dltEX_EV_arg,
                                       MWda,MRHa,MWdd,MRHd);
                        i_SA = - Q_total * (t_SW + t_OP) / t_OP / ua_EV / Af / roua + i_RA;
                        T_SA = (i_SA - Y_SA / 1000 * hfg) / (cpa + cpv * Y_SA / 1000);
                        dltTSA_try1 = Ta_EVout_arg - T_SA;
                        t_OP = YSA2top(flag_Tr_EV_print,Gr_CM,Tr_CD,
                                       Tr_EV_try2,Wd_CD_end,
                                       hs_EV,cp_eq_EV,Ky_EV,hr_EV,Ta_EVin,Ya_EVin,
                                       Ta_EVout_arg,Y_SA,Wd_EV_end,
                                       EXa_EVin,EXr_EVin_arg,EXd_EV_start,EXa_EVout_arg,EXr_EVout_arg,EXd_EV_end,dltEX_EV_arg,
                                       MWda,MRHa,MWdd,MRHd);
                        i_SA = - Q_total * (t_SW + t_OP) / t_OP / ua_EV / Af / roua + i_RA;
                        T_SA = (i_SA - Y_SA / 1000 * hfg) / (cpa + cpv * Y_SA / 1000);
                        dltTSA_try2 = Ta_EVout_arg - T_SA;
                        cout<<"Iteration Tr_EV!!!"<<'\t'<<Tr_EV_try1<<'\t'<<dltTSA_try1<<'\t'<<Tr_EV_try2<<'\t'<<dltTSA_try2<<endl;
                        flag_Tr_EV = flag_Tr_EV_print;
                        if (fabs(dltTSA_try2) < 5e-3) flag_Tr_EV_print = 0;
                        if (flag_Tr_EV_print) {
                            Tr_EV_temp = (fabs(dltTSA_try1) < fabs(dltTSA_try2)) ? Tr_EV_try1 : Tr_EV_try2;
                            Tr_EV_try2 = - dltTSA_try2 / (dltTSA_try1 - dltTSA_try2) * (Tr_EV_try1 - Tr_EV_try2) + Tr_EV_try2;
                            Tr_EV_try1 = Tr_EV_temp;
                        }
                        times_Tr_EV++;
                    }
                    Tr_EV = Tr_EV_try2;
                    cout<<"ACCURATE EV temperature!!!"<<'\t'<<t_OP<<'\t'<<Tr_EV<<'\t'<<Ta_EVout_arg<<'\t'<<T_SA<<'\t'<<Y_SA<<endl;
                    /**三层迭代结束**/

                    /**2.3. 计算蒸发器出口焓及其单位干空气质量换热量**/
                    ia_EVout_arg = cpa * Ta_EVout_arg + Y_SA / 1000 * (hfg + cpv * Ta_EVout_arg);
                    dltIEV_qst_arg = (ia_EVin - ia_EVout_arg) + (Ya_EVin - Y_SA) * (qst - hfg) / 1000;
                    cout<<"ATTENTION!!!!!"<<'\t'<<times_t_OP<<'\t'<<t_OP_try<<'\t'<<t_OP<<endl;
                    flag_t_OP = flag_t_OP_print;
                    if (fabs(t_OP - t_OP_try) < 1) flag_t_OP_print = 0;
                    t_OP_try = t_OP;
                    times_t_OP ++;
                }
                /**二层迭代结束**/

                /**3.1. 冷凝侧新风与回风混合得到的混风状态**/
                Ga_CD = ua_CD * Af * roua;
                RA_ratio_CD = GOA_EV / Ga_CD;
                ia_CDin = (1 - RA_ratio_CD) * i_OA + RA_ratio_CD * i_RA;
                Ya_CDin = (1 - RA_ratio_CD) * Y_OA + RA_ratio_CD * Y_RA;
                Ta_CDin = (ia_CDin - Ya_CDin / 1000 * hfg) / (cpa + cpv * Ya_CDin / 1000);

                /**3.2. 冷凝侧传递系数**/
                hs_CD = Update_Hs(ua_CD);
                Ky_CD = Update_Ky(hs_CD, Ta_CDin);
                cp_eq_CD = cpa + Ya_CDin / 1000 * cpv;
                hr_CD = hr_EV;

                /**3.3. 入口火用**/
                EXa_RA_CD = RA_ratio_CD * Ga_CD * ((cpa + Y_RA / 1000 * cpv) * (T_OA + 273.15) * ((T_RA + 273.15) / (T_OA + 273.15) - 1 - log((T_RA + 273.15) / (T_OA + 273.15))) + 8.314e3 / 29 * (T_OA + 273.15) * ((1 + 1.608 * Y_RA / 1000) * log((1 + 1.608 * Y_OA_sat / 1000)/(1 + 1.608 * Y_RA / 1000)) + 1.608 * Y_RA / 1000 * log(Y_RA / Y_OA_sat)));
                EXa_OA_CD = (1 - RA_ratio_CD) * Ga_CD * 8.314e3 / 29 * (T_OA + 273.15) * ((1 + 1.608 * Y_OA / 1000) * log((1 + 1.608 * Y_OA_sat / 1000)/(1 + 1.608 * Y_OA / 1000)) + 1.608 * Y_OA / 1000 * log(Y_OA / Y_OA_sat));
                EXa_CDin = Ga_CD * (cpa + Ya_CDin / 1000 * cpv) * (T_OA + 273.15) * ((Ta_CDin + 273.15) / (T_OA + 273.15) - 1 - log((Ta_CDin + 273.15) / (T_OA + 273.15))) + Ga_CD * 8.314e3 / 29 * (T_OA + 273.15) * ((1 + 1.608 * Ya_CDin / 1000) * log((1 + 1.608 * Y_OA_sat / 1000)/(1 + 1.608 * Ya_CDin / 1000)) + 1.608 * Ya_CDin / 1000 * log(Ya_CDin / Y_OA_sat));
                dltEX_mix2 = EXa_RA_CD + EXa_OA_CD - EXa_CDin;
                cout<<"OA and RA condition!"<<'\t'<<Y_OA<<'\t'<<T_OA<<'\t'<<Y_RA<<'\t'<<T_RA<<endl;
                cout<<"HX inlet air amount!"<<'\t'<<GOA_EV<<'\t'<<Ga_EV<<'\t'<<Ga_CD<<'\t'<<OA_ratio_EV<<'\t'<<RA_ratio_CD<<endl;
                cout<<"HX inlet air condition!"<<'\t'<<Ya_EVin<<'\t'<<Ta_EVin<<'\t'<<Ya_CDin<<'\t'<<Ta_CDin<<endl;

                /**二层迭代：迭代冷凝温度（负荷相等）,并输出吸附剂含湿量**/
                /**4. 迭代冷凝温度**/
                //cout<<endl;
                Tr_CD_try1 = Tr_EV + 27;
                Tr_CD_try2 = Tr_EV + 32;
                flag_Tr_CD_print = 1, flag_Tr_CD = 1;
                times_Tr_CD = 0;
                Wd_CD_BFR = Wd_CD_end;
                while (flag_Tr_CD_print || (flag_Tr_CD && !flag_Wd_print)){

                    dltQ_CD_try1 = TrCD2dltQ(1,Tr_CD_try1,
                                             Tr_EV,dltIEV_qst_arg,Wd_EV_end,t_OP,Gr_CM,
                                             Ya_CDin,Ta_CDin,hs_CD,cp_eq_CD,Ky_CD,hr_CD,Wd_CD_end,
                                             EXa_CDin,EXr_CDin_arg,EXd_CD_start,EXr_CDout_arg,EXa_CDout_arg,EXd_CD_end,dltEX_CD_arg,
                                             P_CM_arg, dltEX_CM_arg, dltEX_TV_arg,
                                             MWda,MRHa,MWdd,MRHd);
                    dltQ_CD_try2 = TrCD2dltQ(flag_Tr_CD_print,Tr_CD_try2,
                                             Tr_EV,dltIEV_qst_arg,Wd_EV_end,t_OP,Gr_CM,
                                             Ya_CDin,Ta_CDin,hs_CD,cp_eq_CD,Ky_CD,hr_CD,Wd_CD_end,
                                             EXa_CDin,EXr_CDin_arg,EXd_CD_start,EXr_CDout_arg,EXa_CDout_arg,EXd_CD_end,dltEX_CD_arg,
                                             P_CM_arg, dltEX_CM_arg, dltEX_TV_arg,
                                             MWda,MRHa,MWdd,MRHd);
                    cout<<"Iteration Tr_CD!!!"<<'\t'<<times_Tr_CD<<'\t'<<Tr_CD_try1<<'\t'<<dltQ_CD_try1<<'\t'<<Tr_CD_try2<<'\t'<<dltQ_CD_try2<<'\t'<<Wd_CD_end<<endl;
                    flag_Tr_CD = flag_Tr_CD_print;
                    flag_Tr_CD_print = (fabs(dltQ_CD_try2) < 5e-1)? 0 : 1;
                    if(times_Tr_CD > 5)flag_Tr_CD_print = (fabs(dltQ_CD_try2) < 2)? 0 : 1;
                    if(times_Tr_CD > 10)flag_Tr_CD_print = (fabs(dltQ_CD_try2) < 30)? 0 : 1;
                    //if(times_Tr_CD > 15)flag_Tr_CD_print = (fabs(dltQ_CD_try2) < 800)? 0 : 1;
                    if (flag_Tr_CD_print){
                        Tr_CD_temp = (fabs(dltQ_CD_try1) < fabs(dltQ_CD_try2)) ? Tr_CD_try1 : Tr_CD_try2;
                        Tr_CD_try2 = - dltQ_CD_try2 / (dltQ_CD_try1 - dltQ_CD_try2) * (Tr_CD_try1 - Tr_CD_try2) + Tr_CD_try2;
                        //if (times_Tr_CD == 15) Tr_CD_try2 = Tr_EV + 40;
                        Tr_CD_try1 = Tr_CD_temp;
                    }
                    times_Tr_CD ++;
                }
                Tr_CD = Tr_CD_try2;
                /**二层迭代结束**/

                flag_Wd = flag_Wd_print;
                if (times_Wd > 10) Wd_CD_end = Wd_CD_BFR / 2 + Wd_CD_end / 2;
                if (fabs((Wd_CD_BFR - Wd_CD_end) / Wd_CD_end) < 1e-2 || max(fabs(Wd_CD_BFR),fabs(Wd_CD_end))<1e-2) flag_Wd_print = 0;
                times_Wd++;
                cout<<"DESICCANT MOISTURE HUMIDITY!!!"<<'\t'<<times_Wd<<'\t'<<Wd_CD_BFR<<'\t'<<Wd_CD_end<<'\t'<<Wd_EV_end<<endl;
                cout<<endl;
            }
            /**一层迭代结束**/

            /**5.1. 再热器**/
            double EXa_SA, dltEX_HT;
            EXa_SA = Ga_EV * (cpa + Y_SA / 1000 * cpv) * (T_OA + 273.15) * ((T_SA + 273.15) / (T_OA + 273.15) - 1 - log((T_SA + 273.15) / (T_OA + 273.15))) + Ga_EV * 8.314e3 / 29 * (T_OA + 273.15) * ((1 + 1.608 * Y_SA / 1000) * log((1 + 1.608 * Y_OA_sat / 1000)/(1 + 1.608 * Y_SA / 1000)) + 1.608 * Y_SA / 1000 * log(Y_SA / Y_OA_sat));
            dltEX_HT = EXa_EVout_arg - EXa_SA;


            /**5.2. 风机**/
            double P_DF_EV, P_DF_CD;
            P_DF_EV = 2 * Ga_EV / roua * (Update_dltP(ua_EV) + roua * pow(ua_EV, 2)) / yt_DF;
            P_DF_CD = 2 * Ga_CD / roua * (Update_dltP(ua_CD) + roua * pow(ua_CD, 2)) / yt_DF;

            /**5.3.1.切换时压缩机做功1**/
            bool flag_xr;
            int times_xr;
            double xr_EVin, xr_EVin_try;
            double pr_EVin, pr_EVout, ir_EVout, sr_EVout;
            double pr_CDout, ir_CDout, pr_CDin, Tr_CMout_ideal, ir_CMout_ideal, ir_CMout, Tr_CMout;
            double Q_SW, P_CM_SW;
            pr_EVin = 1000 * SaturatedGPT(Tr_EV);
            xr_EVin_try = 0.2;
            flag_xr = 1, times_xr = 0;
            while (flag_xr){
                pr_EVout = pr_EVin - Update_dltPr(Tr_EV, Gr_CM, xr_EVin_try) * lt;
                ir_EVout = 1000 * SuperHeatedHT(pr_EVout, Tr_EV + 5);
                pr_CDout = 1000 * SaturatedLPT(Tr_CD);
                ir_CDout = 1000 * SubCooledHT(pr_CDout, Tr_CD - 10);
                xr_EVin = TwoPhaseXH(ir_CDout, pr_EVout);
                if (fabs(xr_EVin_try - xr_EVin) < 1e-2) flag_xr = 0;
                //cout<<"EVAPORATOR PRESSURE DROP"<<'\t'<<times_xr<<'\t'<<xr_EVin_try<<'\t'<<xr_EVin<<'\t'<<Update_dltPr(Tr_EV, Gr_CM, xr_EVin_try) * lt<<'\t'<<Update_dltPr(Tr_CD, Gr_CM, 0) * lt<<endl;
                xr_EVin_try = xr_EVin;
                times_xr++;
            }
            sr_EVout = 1000 * SuperHeatedST(pr_EVout, Tr_EV + 5);
            pr_CDin = pr_CDout + Update_dltPr(Tr_CD, Gr_CM, 0) * lt;
            Tr_CMout_ideal = SuperHeatedTS(pr_CDin, sr_EVout / 1000) - 273.15;
            ir_CMout_ideal = 1000 * SuperHeatedHT(pr_CDin, Tr_CMout_ideal);
            ir_CMout = (ir_CMout_ideal - ir_EVout) / yt_CM + ir_EVout;

            Q_SW = (Vcu * roucu * ccu + Val * roual * cal + Vd * roud * cd) * (Tr_CD - Tr_EV) / t_SW;
            P_CM_SW = Q_SW / (ir_EVout - ir_CDout) * (ir_CMout - ir_EVout) / ytele_CM;

            //cout<<pr_EVin<<'\t'<<ir_EVout<<'\t'<<pr_EVout<<'\t'<<ir_CDout<<endl;


            /**5.3.2.切换时压缩机做功2**/
            int j, N;
            double ir_EV, pr_EV, sr_EV, rour_EV;
            double ir_CD, pr_CD, sr_CD, rour_CD;
            double exr_EV, Ir_EV, Mr_EV, EXr_EV;
            double exr_CD, Ir_CD, Mr_CD, EXr_CD;
            N = 100;
            Ir_EV = 0, Mr_EV = 0, EXr_EV = 0;
            for (j = 0; j < N; j++){
                ir_EV = (ir_EVout - ir_CDout) / N * j + ir_CDout;
                pr_EV = (pr_EVout - pr_EVin) / N * j + pr_EVin;
                Ir2Sr(ir_EV, pr_EV, sr_EV, rour_EV);
                exr_EV = ir_EV - T_OA * sr_EV;
                Mr_EV = Mr_EV + pi * pow(ri,2) * lt / N * rour_EV;
                Ir_EV = Ir_EV + pi * pow(ri,2) * lt / N * rour_EV * ir_EV;
                EXr_EV =  EXr_EV + pi * pow(ri,2) * lt / N * rour_EV * exr_EV;
            }

            Ir_CD = 0, Mr_CD = 0, EXr_CD = 0;
            for (j = 0; j< N; j++){
                ir_CD = (ir_CDout - ir_CMout) / N * j + ir_CMout;
                pr_CD = (pr_CDout - pr_CDin) / N * j + pr_CDin;
                Ir2Sr(ir_CD, pr_CD, sr_CD, rour_CD);
                exr_CD = ir_CD - T_OA * sr_CD;
                Mr_CD = Mr_CD + pi * pow(ri,2) * lt / N * rour_CD;
                Ir_CD = Ir_CD + pi * pow(ri,2) * lt / N * rour_CD * ir_CD;
                EXr_CD =  EXr_CD + pi * pow(ri,2) * lt / N * rour_CD * exr_CD;
            }

            cout<<Mr_EV<<'\t'<<Mr_CD<<endl;
            double rour_arg, ir_arg, sr_arg;
            double pr_arg_temp, pr_arg_try1, pr_arg_try2, rour_arg_try1, rour_arg_try2, sr_arg_try1, sr_arg_try2;
            double EXr_arg, P_CM_SW2;
            bool flag_pr;
            int times_pr;

            rour_arg = (Mr_EV + Mr_CD) / pi / pow(ri,2) / lt / 2;
            ir_arg = (Ir_EV + Ir_CD) / pi / pow(ri,2) / lt / 2 / rour_arg;
            cout<<rour_arg<<'\t'<<ir_arg<<endl;
            pr_arg_try1 = pr_EV / 2 + pr_CD / 2;
            pr_arg_try2 = 2 * pr_EV / 3 + pr_CD / 3;

            flag_pr = 1;
            times_pr = 1;
            while (flag_pr){

                Ir2Sr(ir_arg, pr_arg_try1, sr_arg_try1, rour_arg_try1);
                Ir2Sr(ir_arg, pr_arg_try2, sr_arg_try2, rour_arg_try2);

                if (fabs((rour_arg_try2 - rour_arg) / rour_arg) < 1e-5) flag_pr = 0;
                pr_arg_temp = (fabs(rour_arg_try1 - rour_arg) < fabs(rour_arg_try2 - rour_arg)) ? pr_arg_try1 : pr_arg_try2;
                pr_arg_try2 = (rour_arg - rour_arg_try1) / (rour_arg_try2 - rour_arg_try1) * (pr_arg_try2 - pr_arg_try1) + pr_arg_try1;
                pr_arg_try1 = pr_arg_temp;
                times_pr++;
            }
            sr_arg = sr_arg_try2;
            EXr_arg =  (Mr_EV + Mr_CD) * (ir_arg - T_OA * sr_arg);
            P_CM_SW2 = (EXr_CD + EXr_EV - EXr_arg) / ytele_CM;

            /**6.0. 定义时间比**/
            double OP_ratio, SW_ratio;
            OP_ratio = t_OP / (t_OP + t_SW);
            SW_ratio = t_SW / (t_OP + t_SW);

            cout<<endl;
            cout<<ua_EV<<'\t'<<ua_CD<<'\t'<<Gr_CM / pi / pow(ri,2)<<endl;
            cout<<"RESULTS"<<endl;
            cout<<"INPUT"<<'\t'<<P_CM_arg * OP_ratio<<'\t'<<EXa_OA_CD * OP_ratio<<'\t'<<EXa_RA_CD * OP_ratio<<'\t'<<EXa_OA_EV * OP_ratio<<'\t'<<EXa_RA_EV * OP_ratio<<'\t'<<EXd_EV_start / t_OP * OP_ratio<<'\t'<<EXd_CD_start / t_OP * OP_ratio<<'\t'<<(P_CM_arg + EXa_RA_CD + EXa_RA_EV + EXa_OA_CD + EXa_OA_EV) * OP_ratio + (EXd_EV_start + EXd_CD_start) / t_OP * OP_ratio<<endl;
            cout<<"OUTPUT"<<'\t'<<EXa_SA * OP_ratio<<'\t'<<EXd_EV_end / t_OP * OP_ratio<<'\t'<<EXa_CDout_arg * OP_ratio<<'\t'<<EXd_CD_end / t_OP * OP_ratio <<'\t'<<(EXa_SA + EXa_CDout_arg) * OP_ratio + EXd_EV_end / t_OP * OP_ratio + EXd_CD_end / t_OP * OP_ratio<<endl;
            cout<<"SWITCHOVER DISSPI"<<'\t'<<(P_CM_SW + P_CM_SW2) * SW_ratio<<endl;
            cout<<"CM DISSPI"<<'\t'<<dltEX_CM_arg * OP_ratio<<endl;
            cout<<"CD DISSPI"<<'\t'<<dltEX_mix2 * OP_ratio<<'\t'<<dltEX_CD_arg * OP_ratio<<'\t'<<(dltEX_mix2 + dltEX_CD_arg) * OP_ratio<<endl;
            cout<<"TV DISSPI"<<'\t'<<dltEX_TV_arg * OP_ratio<<endl;
            cout<<"EV DISSPI"<<'\t'<<dltEX_mix1 * OP_ratio<<'\t'<<dltEX_EV_arg * OP_ratio<<'\t'<<(dltEX_mix1 + dltEX_EV_arg) * OP_ratio<<endl;
            cout<<"HT DISSPI"<<'\t'<<dltEX_HT * OP_ratio<<endl;
            cout<<"OUTPUT+DISSPI"<<'\t'<<(EXa_SA + EXa_CDout_arg + dltEX_CM_arg + dltEX_mix2 + dltEX_CD_arg + dltEX_TV_arg + dltEX_mix1 + dltEX_EV_arg + dltEX_HT) * OP_ratio + EXd_EV_end / t_OP * OP_ratio + EXd_CD_end / t_OP * OP_ratio<<endl;
            cout<<"FAN INPUT"<<'\t'<<P_DF_CD * OP_ratio<<'\t'<<P_DF_EV * OP_ratio<<'\t'<<endl;
            cout<<"ELECTRICITY COMSU"<<'\t'<<(P_DF_CD + P_DF_EV + P_CM_arg) * OP_ratio + P_CM_SW * SW_ratio + P_CM_SW2 * SW_ratio<<endl;
            cout<<Vcu * roucu * ccu<<'\t'<<Val * roual * cal<<'\t'<<Vd * roud * cd<<'\t'<<P_CM_SW<<'\t'<<P_CM_SW2<<endl;
            cout<<endl;

            outfile_EX<<ua_EV<<'\t'<<ua_CD<<'\t'<<Tr_EV<<'\t'<<Tr_CD<<'\t'<<t_OP<<'\t'<<P_CM_SW * SW_ratio + P_CM_SW2 * SW_ratio + P_CM_arg * OP_ratio<<'\t'<<U_ratio<<'\t'<<(P_DF_CD + P_DF_EV + P_CM_arg) * OP_ratio + P_CM_SW2 * SW_ratio + P_CM_SW * SW_ratio;
            outfile_EX<<'\t'<<P_CM_arg * OP_ratio<<'\t'<<P_DF_EV * OP_ratio<<'\t'<<P_DF_CD * OP_ratio<<'\t'<<(P_CM_SW + P_CM_SW2) * SW_ratio<<'\t'<<EXa_OA_CD * OP_ratio<<'\t'<<EXa_RA_CD * OP_ratio<<'\t'<<EXa_OA_EV * OP_ratio<<'\t'<<EXa_RA_EV * OP_ratio;
            outfile_EX<<'\t'<<EXa_SA * OP_ratio<<'\t'<<EXa_CDout_arg * OP_ratio<<'\t'<<dltEX_CM_arg * OP_ratio<<'\t'<<dltEX_TV_arg * OP_ratio<<'\t'<<dltEX_EV_arg * OP_ratio<<'\t'<<dltEX_CD_arg * OP_ratio<<'\t'<<dltEX_mix1 * OP_ratio<<'\t'<<dltEX_mix2 * OP_ratio<<'\t'<<dltEX_HT * OP_ratio;
            outfile_EX<<'\t'<<(P_CM_SW + P_CM_SW2) * SW_ratio<<'\t'<<P_DF_EV * OP_ratio<<'\t'<<P_DF_CD * OP_ratio<<'\t'<< (EXd_EV_end - EXd_EV_start) / t_OP * OP_ratio + (EXd_CD_end - EXd_CD_start) / t_OP * OP_ratio<<endl;
        }
    }
    infile1.close();
    outfile_EV.close();
    outfile_CD.close();
    outfile_EX.close();
    return 0;
}

/**通过送风需求计算运行时间**/
inline double YSA2top(bool flag_print, double Gr, double Tr_CD,
                        double Tr_EV, double Wd_EV_start,
                        double hs_EV, double cp_eq_EV, double Ky_EV, double hr_EV,
                        double Ta_EVin, double Ya_EVin, double &Ta_EVout_targ, double &Y_SA_temp, double &Wd_EV,
                        double EXa_EVin, double &EXr_EVin_targ, double &EXd_EVstart, double &EXa_EVout_targ, double &EXr_EVout_targ, double &EXd_EVend, double &dltEX_EV_targ,
                        double Wda[], double RHa[], double Wdd[], double RHd[]){

    bool flag_xr;
    int times_xr;
    double xr_EVin, xr_EVin_try;

    double Uo_EV, Yd_EV, Td_EV, Wd_EV_BFR;
    double Y_SA;
    double Ya_EVout, Ya_EVout_sum, Ya_EVout_targ, dltYSA, dltYSA_BFR;
    double Ta_EVout, Ta_EVout_sum;
    double t_OP;

    double ir_ref, sr_ref;
    double pr_EVout, ir_EVout, sr_EVout, pr_EVin;
    double pr_CDout, ir_CDout, pr_CDin;
    double Tr_CMout_ideal, ir_CMout_ideal, ir_CMout, Tr_CMout, sr_EVin;

    double ia_EVin, ia_EVout, dltIEV_qst;
    double EXr_EVin, EXa_EVout, EXr_EVout, dltEX_EV;
    double EXr_EVin_sum, EXa_EVout_sum, EXr_EVout_sum;

    double EXd_EVend_BFR;


    if (!flag_print) {
        ir_ref = 1000 * SuperHeatedHT(Patm, T_OA);
        sr_ref = 1000 * SuperHeatedST(Patm, T_OA);
        pr_EVin = 1000 * SaturatedGPT(Tr_EV);

        xr_EVin_try = 0.2;
        flag_xr = 1, times_xr = 0;
        while (flag_xr){
            pr_EVout = pr_EVin - Update_dltPr(Tr_EV, Gr, xr_EVin_try) * lt;
            ir_EVout = 1000 * SuperHeatedHT(pr_EVout, Tr_EV + 5);
            pr_CDout = 1000 * SaturatedLPT(Tr_CD);
            ir_CDout = 1000 * SubCooledHT(pr_CDout, Tr_CD - 10);
            xr_EVin = TwoPhaseXH(ir_CDout, pr_EVout);
            if (fabs(xr_EVin_try - xr_EVin) < 1e-2) flag_xr = 0;
            //cout<<"EVAPORATOR PRESSURE DROP"<<'\t'<<times_xr<<'\t'<<xr_EVin_try<<'\t'<<xr_EVin<<'\t'<<Update_dltPr(Tr_EV, Gr, xr_EVin_try) * lt<<endl;
            xr_EVin_try = xr_EVin;
            times_xr++;
        }
        sr_EVout = 1000 * SuperHeatedST(pr_EVout, Tr_EV + 5);
        pr_CDin = pr_CDout + Update_dltPr(Tr_CD, Gr, 0) * lt;                     /**这里的Gr是平均值**/
        Tr_CMout_ideal = SuperHeatedTS(pr_CDin, sr_EVout / 1000) - 273.15;
        ir_CMout_ideal = 1000 * SuperHeatedHT(pr_CDin, Tr_CMout_ideal);
        ir_CMout = (ir_CMout_ideal - ir_EVout) / yt_CM + ir_EVout;
        Tr_CMout = SuperHeatedTH(pr_CDin, ir_CMout) - 273.15;
        sr_EVin = 1000 * TwoPhaseSH(ir_CDout, pr_EVin);
        EXr_EVin_targ = EXa_EVout_targ = EXr_EVout_targ = 0;
        //cout<<"CONDENSER PRESSURE DROP"<<'\t'<<Update_dltPr(Tr_CD, Gr, 0) * lt<<endl;
    }

    Wd_EV = Wd_EV_start;
    t_OP = 0;
    Ya_EVout_sum = Ya_EVout_targ = 0;
    Ta_EVout_sum = Ta_EVout_targ = 0;
    dltYSA_BFR = 1;
    //cout<<endl;
    while (t_OP <= 5000){

        Uo_EV = Tr2Uo(Tr_EV,Wd_EV,Ya_EVin,Ta_EVin,ua_EV,hs_EV,cp_eq_EV,Ky_EV,hr_EV,Td_EV,Yd_EV,Wda,RHa,Wdd,RHd);    /**Uo_EV, Yd_EV是输出量**/
        if (!flag_print && t_OP < dlt / 2) EXd_EVend_BFR = EXd_EVstart = Ao * td * roud * Wd2EXd(Td_EV, Wd_EV,Wda,RHa,Wdd,RHd);
        Ta_EVout = (Ta_EVin - Tr_EV) * exp( - Uo_EV / roua / ua_EV / cp_eq_EV / la * Lx) + Tr_EV;
        if(Ya_EVin > Yd_EV){
            Ya_EVout = (Ya_EVin - Yd_EV) * exp( - Ky_EV / roua / ua_EV / la * Lx) + Yd_EV;
            Wd_EV = dlt * ua_EV * Af * roua * (Ya_EVin - Ya_EVout) / 1000 / Ao / td / roud + Wd_EV;
        }
        else Ya_EVout = Ya_EVin;
        t_OP = t_OP + dlt;
        Y_SA_temp = - Q_total * QL_ratio * (t_SW + t_OP) / t_OP / hfg * 1000 / ua_EV / Af / roua + Y_RA;
        Ya_EVout_sum = Ya_EVout * dlt + Ya_EVout_sum;
        Ya_EVout_targ = Ya_EVout_sum / t_OP;
        //Ta_EVout_sum = Ta_EVout * dlt + Ta_EVout_sum;
        //Ta_EVout_targ = Ta_EVout_sum / t_OP;
        dltYSA = Ya_EVout_targ - Y_SA_temp;
        //cout<<t_OP<<'\t'<<Uo_EV<<'\t'<<Wd_EV<<'\t'<<Td_EV<<'\t'<<Yd_EV<<'\t'<<Ta_EVout<<'\t'<<Ya_EVout<<'\t'<<Ya_EVout_targ<<'\t'<<Y_SA_temp<<'\t'<<dltYSA<<endl;


        /**瞬时火用值计算+（也包含其他量）输出**/
        if (!flag_print) {

            ia_EVin = cpa * Ta_EVin + Ya_EVin / 1000 * (hfg + cpv * Ta_EVin);
            ia_EVout = cpa * Ta_EVout + Ya_EVout / 1000 * (hfg + cpv * Ta_EVout);
            dltIEV_qst = (ia_EVin - ia_EVout) + (Ya_EVin - Ya_EVout) * (qst - hfg) / 1000;
            Gr = ua_EV * Af * roua * dltIEV_qst / (ir_EVout - ir_CDout);
            EXr_EVin = Gr * (ir_CDout - (T_OA + 273.15) * sr_EVin - ir_ref + (T_OA + 273.15) * sr_ref);   /**这里的Gr是瞬时值**/

            EXa_EVout = ua_EV * Af * roua * (cpa + Ya_EVout / 1000 * cpv) * (T_OA + 273.15) * ((Ta_EVout + 273.15) / (T_OA + 273.15) - 1 - log((Ta_EVout + 273.15) / (T_OA + 273.15))) + ua_EV * Af * roua * 8.314e3 / 29 * (T_OA + 273.15) * ((1 + 1.608 * Ya_EVout / 1000) * log((1 + 1.608 * Y_OA_sat / 1000)/(1 + 1.608 * Ya_EVout / 1000)) + 1.608 * Ya_EVout / 1000 * log(Ya_EVout / Y_OA_sat));
            EXr_EVout = Gr * (ir_EVout - (T_OA + 273.15) * sr_EVout - ir_ref + (T_OA + 273.15) * sr_ref);
            EXd_EVend = Ao * td * roud * Wd2EXd(Td_EV, Wd_EV,Wda,RHa,Wdd,RHd);                           /**因与Wd有关需要在最后一步做调整**/
            dltEX_EV = EXa_EVin + EXr_EVin + EXd_EVend_BFR - EXa_EVout - EXr_EVout - EXd_EVend;
            EXd_EVend_BFR = EXd_EVend;
            outfile_EV<<t_OP<<'\t'<<Gr / pi / pow(ri,2)<<'\t'<<Uo_EV<<'\t'<<Wd_EV<<'\t'<<Td_EV<<'\t'<<Yd_EV<<'\t'<<Ta_EVout<<'\t'<<Ya_EVout<<'\t'<<Ya_EVout_targ<<'\t'<<Y_SA_temp<<'\t'<<dltYSA<<'\t'<<Gr<<'\t'<<EXa_EVin<<'\t'<<EXr_EVin<<'\t'<<EXd_EVstart<<'\t'<<EXa_EVout<<'\t'<<EXr_EVout<<'\t'<<EXd_EVend<<'\t'<<dltEX_EV<<endl;

        }

        /**最后一步输出参数**/
        if ((dltYSA > 0) && (dltYSA_BFR < 0)) {
            t_OP = t_OP - dlt / (dltYSA - dltYSA_BFR) * dltYSA;
            Wd_EV = Wd_EV - (Wd_EV - Wd_EV_BFR) / (dltYSA - dltYSA_BFR) * dltYSA;
            Ta_EVout_sum = Ta_EVout * dlt / (dltYSA - dltYSA_BFR) * fabs(dltYSA_BFR) + Ta_EVout_sum;
            if(!flag_print){
                EXd_EVend = Ao * td * roud * Wd2EXd(Td_EV, Wd_EV,Wda,RHa,Wdd,RHd);
                dltEX_EV = EXa_EVin + EXr_EVin + EXd_EVend_BFR - EXa_EVout - EXr_EVout - EXd_EVend;
                EXr_EVin_sum = EXr_EVin * dlt / (dltYSA - dltYSA_BFR) * fabs(dltYSA_BFR) + EXr_EVin_sum;
                EXa_EVout_sum = EXa_EVout * dlt / (dltYSA - dltYSA_BFR) * fabs(dltYSA_BFR) + EXa_EVout_sum;
                EXr_EVout_sum = EXr_EVout * dlt / (dltYSA - dltYSA_BFR) * fabs(dltYSA_BFR) + EXr_EVout_sum;
                outfile_EV<<t_OP<<'\t'<<Uo_EV<<'\t'<<Wd_EV<<'\t'<<Td_EV<<'\t'<<Yd_EV<<'\t'<<Ta_EVout<<'\t'<<Ya_EVout<<'\t'<<Ya_EVout_targ<<'\t'<<Y_SA_temp<<'\t'<<dltYSA<<'\t'<<Gr<<'\t'<<EXa_EVin<<'\t'<<EXr_EVin<<'\t'<<EXd_EVstart<<'\t'<<EXa_EVout<<'\t'<<EXr_EVout<<'\t'<<EXd_EVend<<'\t'<<dltEX_EV<<endl;
                outfile_EV<<endl;
            }
            break;
        }
        else {
            Ta_EVout_sum = Ta_EVout * dlt + Ta_EVout_sum;
            if(!flag_print){
                //EXd_EVend = Ao * td * roud * Wd2EXd(Td_EV, Wd_EV);
                //dltEX_EV = EXa_EVin + EXr_EVin + EXd_EVstart - EXa_EVout - EXr_EVout - EXd_EVend;
                EXr_EVin_sum = EXr_EVin * dlt + EXr_EVin_sum;
                EXa_EVout_sum = EXa_EVout * dlt + EXa_EVout_sum;
                EXr_EVout_sum = EXr_EVout * dlt + EXr_EVout_sum;
            }
        }
        dltYSA_BFR = dltYSA;
        Wd_EV_BFR = Wd_EV;
    }

    Ta_EVout_targ = Ta_EVout_sum / t_OP;
    /**平均火用值计算**/
    if (!flag_print) {
        EXr_EVin_targ = EXr_EVin_sum / t_OP;
        EXa_EVout_targ = EXa_EVout_sum / t_OP;
        EXr_EVout_targ = EXr_EVout_sum / t_OP;
        dltEX_EV_targ = EXa_EVin + EXr_EVin_targ + (EXd_EVstart - EXd_EVend) / t_OP - EXa_EVout_targ - EXr_EVout_targ;
    }
    return t_OP;
}

/**通过能量校核计算冷凝温度**/
inline double TrCD2dltQ(bool flag_print, double Tr_CD,
                         double Tr_EV, double dltIEV_qst, double Wd_CD_start, double t_OP, double &Gr,
                         double Ya_CDin, double Ta_CDin, double hs_CD, double cp_eq_CD, double Ky_CD, double hr_CD, double &Wd_CD,
                         double EXa_CDin, double &EXr_CDin, double &EXd_CDstart, double &EXr_CDout, double &EXa_CDout_targ, double &EXd_CDend, double &dltEX_CD_targ,
                         double &P_CM, double &dltEX_CM, double &dltEX_TV,
                         double Wda[], double RHa[], double Wdd[], double RHd[]){

    bool flag_xr;
    int times_xr;
    double xr_EVin, xr_EVin_try;

    bool flag_Gr;
    int times_Gr;
    double Gr_try;
    double pr_EVin, pr_EVout, ir_EVout, sr_EVout;
    double pr_CDout, ir_CDout, pr_CDin;
    double Tr_CMout_ideal, ir_CMout_ideal, ir_CMout, Tr_CMout;
    double Qr_CD;

    double ir_ref, sr_ref, sr_CMout, sr_CDout_sat, sr_CDout;
    double EXr_EVout, sr_EVin, EXr_EVin;

    double Uo_CD, Yd_CD, Td_CD, t_CD;
    double Ya_CDout, Ta_CDout;
    double Ya_CDout_sum, Ta_CDout_sum, Ya_CDout_targ, Ta_CDout_targ;
    double ia_CDout, ia_CDin;
    double Qa_CD, dltQ;
    double EXa_CDout, dltEX_CD;

    double EXd_CDend_BFR;

    Gr_try = 500 * pi * pow(ri,2);
    flag_Gr = 1, times_Gr = 0;
    while (flag_Gr){
        pr_EVin = 1000 * SaturatedGPT(Tr_EV);

        xr_EVin_try = 0.2;
        flag_xr = 1, times_xr = 0;
        while (flag_xr){
            pr_EVout = pr_EVin - Update_dltPr(Tr_EV, Gr_try, xr_EVin_try) * lt;
            ir_EVout = 1000 * SuperHeatedHT(pr_EVout, Tr_EV + 5);
            pr_CDout = 1000 * SaturatedLPT(Tr_CD);
            ir_CDout = 1000 * SubCooledHT(pr_CDout, Tr_CD - 10);
            xr_EVin = TwoPhaseXH(ir_CDout, pr_EVout);
            if (fabs(xr_EVin_try - xr_EVin) < 1e-2) flag_xr = 0;
            //cout<<"EVAPORATOR PRESSURE DROP"<<'\t'<<times_xr<<'\t'<<xr_EVin_try<<'\t'<<xr_EVin<<'\t'<<Update_dltPr(Tr_EV, Gr_try, xr_EVin_try) * lt<<endl;
            xr_EVin_try = xr_EVin;
            times_xr++;
        }
        sr_EVout = 1000 * SuperHeatedST(pr_EVout, Tr_EV + 5);
        pr_CDin = pr_CDout + Update_dltPr(Tr_CD, Gr_try, 0) * lt;
        Tr_CMout_ideal = SuperHeatedTS(pr_CDin, sr_EVout / 1000) - 273.15;
        ir_CMout_ideal = 1000 * SuperHeatedHT(pr_CDin, Tr_CMout_ideal);
        ir_CMout = (ir_CMout_ideal - ir_EVout) / yt_CM + ir_EVout;
        Tr_CMout = SuperHeatedTH(pr_CDin, ir_CMout) - 273.15;
        sr_EVin = 1000 * TwoPhaseSH(ir_CDout, pr_EVin);
        //cout<<"CONDENSER PRESSURE DROP"<<'\t'<<Update_dltPr(Tr_CD, Gr_try, 0) * lt<<endl;

        Gr = ua_EV * Af * roua * dltIEV_qst / (ir_EVout - ir_CDout);
        if (fabs((Gr_try - Gr) / Gr) < 1e-2) flag_Gr = 0;
        //cout<<times_Gr<<'\t'<<Gr_try<<'\t'<<Gr<<endl;
        Gr_try = Gr;
        times_Gr++;
    }
    Qr_CD = Gr * (ir_CMout - ir_CDout);

    if(!flag_print) {

        ir_ref = 1000 * SuperHeatedHT(Patm, T_OA);
        sr_ref = 1000 * SuperHeatedST(Patm, T_OA);
        sr_CMout = 1000 * SuperHeatedST(pr_CDin,Tr_CMout);
        sr_CDout_sat = 1000 * SaturatedLST(Tr_CD);
        sr_CDout = sr_CDout_sat + SubCooledCpT(pr_CDin, Tr_CD - 5) * log((Tr_CD + 263.15)/(Tr_CD + 273.15));
        EXr_CDin = Gr * (ir_CMout - (T_OA + 273.15) * sr_CMout - ir_ref + (T_OA + 273.15) * sr_ref);
        EXr_CDout = Gr * (ir_CDout - (T_OA + 273.15) * sr_CDout - ir_ref + (T_OA + 273.15) * sr_ref);
        P_CM = Gr * (ir_CMout - ir_EVout) / ytele_CM;
        EXr_EVout = Gr * (ir_EVout - (T_OA + 273.15) * sr_EVout - ir_ref + (T_OA + 273.15) * sr_ref);
        dltEX_CM = P_CM + EXr_EVout - EXr_CDin;
        sr_EVin = 1000 * TwoPhaseSH(ir_CDout, pr_EVin);
        EXr_EVin = Gr * (ir_CDout - (T_OA + 273.15) * sr_EVin - ir_ref + (T_OA + 273.15) * sr_ref);
        dltEX_TV = EXr_CDout - EXr_EVin;
    }
    //cout<<Qr_CD<<endl;

    Wd_CD = min(Wd_CD_start,Wdd[N_Wda - 1]);
    Ya_CDout_sum = 0;
    Ta_CDout_sum = 0;
    EXa_CDout_targ = 0;
    for (t_CD = 0; t_CD <= t_OP; t_CD = t_CD + dlt){

        Uo_CD = Tr2Uo(Tr_CD,Wd_CD,Ya_CDin,Ta_CDin,ua_CD,hs_CD,cp_eq_CD,Ky_CD,hr_CD,Td_CD,Yd_CD,Wda,RHa,Wdd,RHd);
        if (!flag_print && t_CD < dlt / 2) EXd_CDend_BFR = EXd_CDstart = Ao * td * roud * Wd2EXd(Td_CD, Wd_CD, Wda, RHa, Wdd, RHd);
        if(Ya_CDin < Yd_CD){
            Ya_CDout = (Ya_CDin - Yd_CD) * exp( - Ky_CD / roua / ua_CD / la * Lx) + Yd_CD;
            Wd_CD = dlt * ua_CD * Af * roua * (Ya_CDin - Ya_CDout) / 1000 / Ao / td / roud + Wd_CD;
        }
        else Ya_CDout = Ya_CDin;
        Ta_CDout = (Ta_CDin - Tr_CD) * exp( - Uo_CD / roua / ua_CD / cp_eq_CD / la * Lx) + Tr_CD;

        Ya_CDout_sum = Ya_CDout * dlt + Ya_CDout_sum;
        Ta_CDout_sum = Ta_CDout * dlt + Ta_CDout_sum;

        if(!flag_print) {
            EXa_CDout = ua_CD * Af * roua * (cpa + Ya_CDout / 1000 * cpv) * (T_OA + 273.15) * ((Ta_CDout + 273.15) / (T_OA + 273.15) - 1 - log((Ta_CDout + 273.15) / (T_OA + 273.15))) + ua_CD * Af * roua * 8.314e3 / 29 * (T_OA + 273.15) * ((1 + 1.608 * Ya_CDout / 1000) * log((1 + 1.608 * Y_OA_sat / 1000)/(1 + 1.608 * Ya_CDout / 1000)) + 1.608 * Ya_CDout / 1000 * log(Ya_CDout / Y_OA_sat));
            EXd_CDend = Ao * td * roud * Wd2EXd(Td_CD, Wd_CD, Wda, RHa, Wdd, RHd);;
            dltEX_CD = EXa_CDin + EXr_CDin + EXd_CDend_BFR - EXa_CDout - EXr_CDout - EXd_CDend;
            EXa_CDout_targ = EXa_CDout * dlt / t_OP + EXa_CDout_targ;
            EXd_CDend_BFR = EXd_CDend;
            outfile_CD<<t_CD<<'\t'<<Uo_CD<<'\t'<<Wd_CD<<'\t'<<Td_CD<<'\t'<<Yd_CD<<'\t'<<Ta_CDout<<'\t'<<Ya_CDout<<'\t'<<EXa_CDin<<'\t'<<EXr_CDin<<'\t'<<EXd_CDstart<<'\t'<<EXr_CDout<<'\t'<<EXa_CDout<<'\t'<<EXd_CDend<<'\t'<<dltEX_CD<<endl;
        }
    }
    Uo_CD = Tr2Uo(Tr_CD,Wd_CD,Ya_CDin,Ta_CDin,ua_CD,hs_CD,cp_eq_CD,Ky_CD,hr_CD,Td_CD,Yd_CD,Wda,RHa,Wdd,RHd);
    Ya_CDout = (Ya_CDin - Yd_CD) * exp( - Ky_CD / roua / ua_CD / la * Lx) + Yd_CD;
    Ta_CDout = (Ta_CDin - Tr_CD) * exp( - Uo_CD / roua / ua_CD / cp_eq_CD / la * Lx) + Tr_CD;
    Wd_CD = (t_OP + dlt - t_CD) * ua_CD * Af * roua * (Ya_CDin - Ya_CDout) / 1000 / Ao / td / roud + Wd_CD;
    Ya_CDout_sum = Ya_CDout * (t_OP + dlt - t_CD) + Ya_CDout_sum;
    Ta_CDout_sum = Ta_CDout * (t_OP + dlt - t_CD) + Ta_CDout_sum;

    if(!flag_print) {
        EXa_CDout = ua_CD * Af * roua * (cpa + Ya_CDout / 1000 * cpv) * (T_OA + 273.15) * ((Ta_CDout + 273.15) / (T_OA + 273.15) - 1 - log((Ta_CDout + 273.15) / (T_OA + 273.15))) + ua_CD * Af * roua * 8.314e3 / 29 * (T_OA + 273.15) * ((1 + 1.608 * Ya_CDout / 1000) * log((1 + 1.608 * Y_OA_sat / 1000)/(1 + 1.608 * Ya_CDout / 1000)) + 1.608 * Ya_CDout / 1000 * log(Ya_CDout / Y_OA_sat));
        EXd_CDend = Ao * td * roud * Wd2EXd(Td_CD, Wd_CD, Wda, RHa, Wdd, RHd);
        dltEX_CD = EXa_CDin + EXr_CDin + EXd_CDend_BFR - EXa_CDout - EXr_CDout - EXd_CDend;
        EXa_CDout_targ = EXa_CDout * (t_OP + dlt - t_CD) / t_OP + EXa_CDout_targ;
        outfile_CD<<t_CD<<'\t'<<Uo_CD<<'\t'<<Wd_CD<<'\t'<<Td_CD<<'\t'<<Yd_CD<<'\t'<<Ta_CDout<<'\t'<<Ya_CDout<<'\t'<<EXa_CDin<<'\t'<<EXr_CDin<<'\t'<<EXd_CDstart<<'\t'<<EXr_CDout<<'\t'<<EXa_CDout<<'\t'<<EXd_CDend<<'\t'<<dltEX_CD<<endl;
    }

    Ya_CDout_targ = Ya_CDout_sum / t_OP;
    Ta_CDout_targ = Ta_CDout_sum / t_OP;
    ia_CDout = cpa * Ta_CDout_targ + Ya_CDout_targ / 1000 * (hfg + cpv * Ta_CDout_targ);

    ia_CDin = cpa * Ta_CDin + Ya_CDin / 1000 * (hfg + cpv * Ta_CDin);
    Qa_CD = - ua_CD * Af * roua * (ia_CDin - ia_CDout + (qst - hfg) * (Ya_CDin - Ya_CDout_targ) / 1000);
    dltQ = Qr_CD - Qa_CD;
    if(!flag_print)dltEX_CD_targ = EXa_CDin + EXr_CDin + (EXd_CDstart - EXd_CDend) / t_OP - EXa_CDout_targ - EXr_CDout;

    return dltQ;
}

/**通过制冷剂温度求Uo**/
inline double Tr2Uo(double Tr, double Wd, double Yain, double Tain, double ua, double hs, double cp_eq, double Ky, double hr, double &Td, double &Yd,
                     double Wda[], double RHa[], double Wdd[], double RHd[]){

    double Uo_try, Uo;
    double Td_try;
    bool flag_Uo,flag_Td;
    int times_Uo,times_Td;

    double QL_ratio_QS, heq, m, c_Bessel, yt_eq, yt;
    double dlTa_xarg, dlTt_xarg, dlTf_xarg;
    double dlTtw_xarg, dlTfw_xarg;

    Uo_try = hs;
    flag_Uo = 1;
    times_Uo = 0;
    while (flag_Uo){

        Td_try = Tr;
        flag_Td = 1;
        times_Td = 0;
        //cout<<endl;
        while (flag_Td){
            Yd = Wd2Yd(1, Td_try, Wd, Wda, RHa, Wdd, RHd);
            QL_ratio_QS = (Yd - Yain) * qst / 1000 * ( 1 - exp(- Ky / roua / ua / la * Lx)) / (Tr - Tain)  / ( 1 - exp(- Uo_try / cp_eq / roua / ua / la * Lx)) / cp_eq;
            if(QL_ratio_QS > 5)QL_ratio_QS = 5;
            if(QL_ratio_QS <= 0)QL_ratio_QS = 0;
            heq = 1 / (1 / hs + (1 + QL_ratio_QS) * td / kd);
            m = sqrt(2 * heq / kf / tf);
            c_Bessel = (second_modified_Bessel(1,m * r1) * first_modified_Bessel(1,m * r2) - first_modified_Bessel(1,m * r1) * second_modified_Bessel(1,m * r2)) /(first_modified_Bessel(0,m * r1) * second_modified_Bessel(1,m * r2) + second_modified_Bessel(0,m * r1) * first_modified_Bessel(1,m * r2));
            yt_eq = 2 * r1 / m / (pow(r2,2) - pow(r1,2)) * c_Bessel;
            yt = yt_eq - (1 - yt_eq) * QL_ratio_QS;
            Uo = 1 /((1 + QL_ratio_QS) * (Ao / hr / Ati + Ao * log(ro/ri) / 2 / pi / kt / lt) + 1 / heq / (Ato / Ao + Afo * yt / Ao));
            dlTa_xarg = roua * ua * cp_eq * la / Uo / Lx * (Tain - Tr) * (1 - exp(- Uo / cp_eq / roua / ua / la * Lx));
            dlTt_xarg = dlTa_xarg * Uo  * ((1 + QL_ratio_QS) * (Ao / hr / Ati + Ao * log(ro/ri) / 2 / pi / kt / lt));
            dlTf_xarg = dlTa_xarg - (dlTa_xarg - dlTt_xarg) * yt;
            dlTtw_xarg = dlTa_xarg - (dlTa_xarg - dlTt_xarg) * heq / hs;
            dlTfw_xarg = dlTa_xarg - (dlTa_xarg - dlTf_xarg) * heq / hs;
            Td = Ato / Ao * dlTtw_xarg + Afo / Ao * dlTfw_xarg + Tr;
            if (fabs((Td_try - Td) / Td) < 1e-3) flag_Td = 0;
            //if (times_Td > 10)if (fabs((Td_try - Td) / Td) < 1e-2) flag_Td = 0;
            Td_try = Td / 2 + Td_try / 2;
            times_Td++;
            //if(times_Td > 10)cout<<times_Td<<'\t'<<Td<<'\t'<<Td_try<<endl;
        }
        if (fabs((Uo_try - Uo) / Uo) < 2e-2) flag_Uo = 0;
        Uo_try = Uo / 2 + Uo_try / 2;
        times_Uo++;
        if(times_Uo > 20)cout<<times_Uo<<'\t'<<Uo<<'\t'<<Uo_try<<endl;
    }
    return Uo;
}

inline double Wd2EXd (double Td, double Wd, double Wda[], double RHa[], double Wdd[], double RHd[]){

    int i, N;
    double Wd_temp, dltWd, Yd;
    double EXd_ch, EXd_ph, EXd;

    N = 100;
    EXd_ch = 0;
    for (i = 1; i <= N; i++){
        Wd_temp = Wd / N * i, dltWd = Wd / N;
        Yd = Wd2Yd(1,T_OA,Wd_temp,Wda,RHa,Wdd,RHd);
        EXd_ch = EXd_ch + dltWd * 8.314e3 / 18 * (T_OA + 273.15) * log (Yd * (1 + 1.608 * Y_OA_sat / 1000) / Y_OA_sat / (1 + 1.608 * Yd / 1000));
        //cout<<Wd<<'\t'<<Td<<'\t'<<Wd_temp<<'\t'<<dltWd<<'\t'<<Yd<<'\t'<<Y_OA_sat<<'\t'<<log (Yd * (1 + 1.608 * Y_OA_sat / 1000) / Y_OA_sat / (1 + 1.608 * Yd / 1000))<<'\t'<<EXd_ch<<endl;
    }
    EXd_ph = Wd * cpw * (T_OA + 273.15) * ((Td + 273.15) / (T_OA + 273.15) - 1 - log((Td + 273.15) / (T_OA + 273.15)));
    EXd = EXd_ph + EXd_ch;
    //cout<<EXd_ph<<'\t'<<EXd<<endl;
    return EXd;
}

inline double Wd2Yd (bool flag_ch, double Td, double Wd, double Wda[], double RHa[], double Wdd[], double RHd[]){

    double Yd, Pvs, RH;
    //Pvs = exp(-5800.2206 / (Tf + 273.15) + 1.3914993 - 0.048640239 * (Tf + 273.15) + 0.000041764768 * pow(Tf + 273.15,2) - 0.000000014452093 * pow(Tf + 273.15,3) + 6.5459673 * log(Tf + 273.15));
    //Yd_SAT = 622  / (Patm / Pvs - 1);
    //Yd = Wd / 0.24 * Yd_SAT;
    int p;
    if(flag_ch){
        for(p = 0; p < N_Wda - 1; p++){
            if(Wda[p] <= Wd && Wd <= Wda[p + 1])break;
            //cout<<Wda[p]<<'\t'<<Wd<<endl;
         }
        if(p == N_Wda - 1){RH = 1;}
        else RH = (Wd - Wda[p]) / (Wda[p + 1] - Wda[p]) * (RHa[p + 1] - RHa[p]) + RHa[p];
    }
    else{
         for(p = 0; p < N_Wdd - 1; p++){
            if(Wdd[p] <= Wd && Wd <= Wdd[p + 1])break;
            //cout<<Wda[p]<<'\t'<<Wd<<endl;
         }
        if(p ==  N_Wdd - 1){RH = 1;}
        else RH = (Wd - Wdd[p]) / (Wdd[p + 1] - Wdd[p]) * (RHd[p + 1] - RHd[p]) + RHd[p];
    }
    Pvs = exp(-5800.2206 / (Td + 273.15) + 1.3914993 - 0.048640239 * (Td + 273.15) + 0.000041764768 * pow(Td + 273.15,2) - 0.000000014452093 * pow(Td + 273.15,3) + 6.5459673 * log(Td + 273.15));

    Yd = 622 * RH / (Patm / Pvs - RH);
    //cout<<p<<'\t'<<Yd<<"here!"<<endl;
    return Yd;


    //if(Wd >= 0.73431) RHd = 1;
    //else {
        //if(Wd >= 0.683 && Wd < 0.73431)RHd = 1 / exp(((Wd -0.68427) / -0.00139 + 36)/ (Tf + 273.15) / (8.314 / 18));
        //else RHd = 1 / exp((pow(- log(Wd / Bd) / Cd, 1/Dd) + 36)/ (Tf + 273.15) / (8.314 / 18));
    //}

    //Pvs = exp(-5800.2206 / (Tf + 273.15) + 1.3914993 - 0.048640239 * (Tf + 273.15) + 0.000041764768 * pow(Tf + 273.15,2) - 0.000000014452093 * pow(Tf + 273.15,3) + 6.5459673 * log(Tf + 273.15));
    //Yd = 622 * RHd / (Patm / Pvs - RHd);
    //return Yd;
}


inline double Update_Hs(double ua){

    double d1, d2;
    double Amin, Af;
    double Dh, dc;
    double Umax, REa, PRa;
    double c3, c4, c5, c6, j;
    double hs;

    d1 = dlz - 2 * ro;
    d2 = 2 * (pow(pow(dlz / 2, 2) + pow(dlx, 2), 0.5) - 2 * ro);
    if(d1 < d2) Amin = nf * Pf * (1 - tf / Pf) * ((ntz - 1) * d1 + d1);
    else Amin = nf * Pf * (1 - tf / Pf) * ((ntz - 1) * d2 + d1);
    Af = nf * Pf * dlz * ntz;

    Dh = 4 * Amin * la / Af;
    dc = 2 * ro + 2 * tf;

    Umax = ua * Af / Amin;
    REa = roua * Umax * dc / mua;
    PRa = mua * cpa / ka;                                                              /**普朗克常数：定义式**/

    c3 = - 0.361 - 0.042 * ntx / log(REa) + 0.158 * log(ntx * pow(Pf / dc, 0.41));
    c4 = - 1.224 - 0.076 * pow(dlx / Dh, 1.42) / log(REa);
    c5 = - 0.083 + 0.058 * ntx / log(REa);
    c6 = - 5.735 + 1.21 * log(REa / ntx);
    j = 0.086 * pow(REa, c3) * pow(ntx, c4) * pow(Pf / dc, c5) * pow(Pf / Dh, c6) * pow(Pf / dlz, -0.93);

    hs = j / pow(PRa, 2.0 / 3) * roua * Umax * cpa;

    return hs;

}

inline double Update_Ky(double ha, double Ta){

    double ky, Da;
    double NUa, PRa, SCa, SHa;

    Da = 2.302e-5 * pow( (Ta + 273.15) / 256,1.81) * 0.98e5 / Patm;

    NUa = ha * Va / Ao / ka;
    PRa = mua * cpa / ka;
    SCa = mua / roua / Da;
    SHa = NUa * pow(SCa, 1.0 / 3) / pow (PRa , 1.0 / 3);
    ky = roua * SHa * Da * Ao / Va;
    //ky = 0.036;
    return ky;
}

inline double Update_dltP(double ua){

    double d1, d2;
    double Amin;
    double Dh, dc;
    double Umax, REa;
    double f_F;
    double c7, c8, c9;
    double dltP1, dltP2, dltP;

    d1 = dlz - 2 * ro;
    d2 = 2 * (pow(pow(dlz / 2, 2) + pow(dlx, 2), 0.5) - 2 * ro);
    if(d1 < d2) Amin = nf * Pf * (1 - tf / Pf) * ((ntz - 1) * d1 + d1);
    else Amin = nf * Pf * (1 - tf / Pf) * ((ntz - 1) * d2 + d1);

    Dh = 4 * Amin * la / Af;
    dc = 2 * ro + 2 * tf;

    Umax = ua * Af / Amin;
    REa = roua * Umax * dc / mua;

    c7 = - 0.764 + 0.739 * (dlz / dlx) + 0.177 * Pf / dc - 0.00758 / ntz;
    c8 = - 15.689 + 64.021 / log(REa);
    c9 = 1.696 - 15.695 / log(REa);
    f_F = 0.0267 * pow(REa, c7) * pow(dlx / dlz, c8) * pow (Pf / dc, c9);
    dltP1 = 4 * pow(Af * ua * roua / Amin,2) / 2 / roua * f_F * dlx * ntx / Dh;

    //dltP2 = pow(ua * roua,2) / 2 / roua * (-0.733 * Amin / Af * 2 + 1.133 + 0.333);
    //dltP = dltP1 + dltP2;
    //cout<<"ATTENTION"<<'\t'<<dltP1<<'\t'<<dltP2<<endl;

    return dltP1;

}

inline double Update_dltPr(double Tr, double Gr, double xr_start){

    int i, N;
    double dltPr, dltPr_avg;
    N = 100;
    dltPr_avg = 0;
    for (i = 1;i <= N; i++){
        dltPr = Update_Frict_TwoPhase(Tr, Gr, xr_start + (1.0 - xr_start) / N * i);
        dltPr_avg = dltPr_avg + dltPr / N;
    }
    //cout<<dltPr<<'\t'<<dltPr_avg<<endl;
    return dltPr_avg;
}
inline double Update_Frict_TwoPhase(double Tr, double Gr, double xr){

    double mr;
    double uL, uG, rouL, rouG;
    double fL, REL, FRL, fFR, dltpL_Z, dltpFr_Z, fyrGD;
    double dltpr_Frict_Z;

    mr = Gr /  pi / pow(ri,2);

    uL = SaturatedLUT(Tr), uG = SaturatedGUT(Tr);
    rouL = SaturatedLRouT(Tr), rouG = SaturatedGRouT(Tr);

    REL = 2 * ri * mr / uL;
    fL = 0.079 / pow(REL, 0.25);
    dltpL_Z = fL * pow(mr, 2) / rouL / ri;

    FRL = pow(mr, 2) / (2 * ri * g * pow(rouL,2));
    if(FRL >= 1) fFR = 1;
    else fFR = pow(FRL, 0.3) + 0.0055 * pow(log(1 / FRL), 2);
    dltpFr_Z = fFR * (xr + 4 * (pow(xr, 1.8) - pow(xr, 10) * pow(fFR, 0.5)));
    fyrGD = 1 + dltpFr_Z * (rouL / rouG / pow(uL / uG, 0.25) - 1);
    dltpr_Frict_Z = fyrGD * dltpL_Z;
    return dltpr_Frict_Z;

}

inline double Ir2Sr(double ir, double pr, double &sr, double &rour){

    double xr, epir, epirMIN, Tr;
    double TrG, TrL, rouG, rouL;

    TrG = SaturatedGTP(pr) - 273.15,TrL = SaturatedLTP(pr) - 273.15;
    if (ir < 1000 * SaturatedGHT(TrG) && ir > 1000 * SaturatedLHT(TrL)){
        sr = 1000 * TwoPhaseSH(ir, pr);
        xr = TwoPhaseXH(ir, pr);
        rouG = SaturatedGRouT(TrG), rouL = SaturatedLRouT(TrL);
        if (xr >= 1e-5)epir = 1 / (1 + (1 - xr) / xr * pow(rouG / rouL, 0.67));
        else {
            epirMIN = 1 / (1 + (1 - 1e-5) / 1e-5 * pow(rouG / rouL, 0.67));
            epir = xr / 1e-5 * epirMIN;
        }
        rour = epir * rouG + (1 - epir) * rouL;
    }
    else{
        if (ir >= 1000 * SaturatedGHT(TrG)){
            Tr = SuperHeatedTH(pr, ir) - 273.15;
            sr = 1000 * SuperHeatedST(pr, Tr);
            rour = SuperHeatedRouT(pr, Tr);
        }
        if (ir <= 1000 * SaturatedLHT(TrL)){
            Tr = SubCooledTH(pr, ir) - 273.15;
            sr = 1000 * SaturatedLST(TrL) + SubCooledCpT(pr, Tr) * log((Tr + 273.15)/(TrL + 273.15));
            rour = SubCooledRouT(pr, Tr);
        }
    }
    //cout<<ir<<'\t'<<pr<<'\t'<<rour<<'\t'<<sr<<endl;
    return Tr;
}

inline double T2Psat(double T){
    double Psat;
    Psat = exp(-5800.2206 / (T + 273.15) + 1.3914993 - 0.048640239 * (T + 273.15) + 0.000041764768 * pow(T + 273.15,2) - 0.000000014452093 * pow(T + 273.15,3) + 6.5459673 * log(T + 273.15));
    return Psat;
}


/**************************************************************************************************************************************************/
double SuperHeatedCpT(double pr, double Tr){
    double cp;
    cp = 1e5 * (SuperHeatedHT(pr,Tr + 0.01) - SuperHeatedHT(pr,Tr));
    //cout<<cp<<endl;
    return cp;
}

double SubCooledCpT(double pr, double Tr){
    double cp;
    cp = 1e5 * (SubCooledHT(pr,Tr) - SubCooledHT(pr,Tr - 0.01));
    //cout<<cp<<endl;
    return cp;
}

inline double SaturatedLUT(double Tr){
    double uL;
    uL = 2.38792070e-13 * pow(Tr, 4) - 1.04671492e-10 * pow(Tr, 3) + 1.81435101e-8 * pow(Tr, 2) - 2.77644014e-6 * Tr + 2.42638774e-4;
    return uL;
}

inline double SaturatedGUT(double Tr){
    double uG;
    uG = -2.77476699e-15 * pow(Tr, 5) + 5.57460712e-13 * pow(Tr, 4) - 3.25865533e-11 * pow(Tr, 3) + 7.45101326e-10 * pow(Tr, 2) + 3.47247943e-8 * Tr + 1.11536344e-5;
    return uG;
}


